---
phase: 02-standardization-intelligence
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/standardization/provenance.py
  - backend/app/services/standardization/fragment_dict.py
  - backend/app/schemas/standardization.py
  - backend/app/api/routes/standardization.py
  - backend/app/services/standardization/chembl_pipeline.py
  - backend/tests/test_standardization/test_provenance.py
autonomous: true
requirements:
  - STD-01
  - STD-02
  - STD-03
  - STD-04

must_haves:
  truths:
    - "A standardization request with include_provenance=true returns a provenance field with per-stage records (checker, standardizer, get_parent, tautomer)"
    - "Each provenance stage record has input_smiles, output_smiles, applied flag, and a typed changes array"
    - "Neutralization provenance (STD-02) reports per-atom charge changes with atom_idx, element, before_charge, after_charge, rule_name, and smarts"
    - "Parent extraction provenance (STD-04) reports removed fragments with smiles, name, role (salt/solvent/counterion/unknown), and mw"
    - "Tautomer provenance (STD-01) reports input_smiles, canonical_smiles, num_tautomers_enumerated, modified_atoms, modified_bonds, stereo_stripped"
    - "Functional group audit (STD-03) reports atom-level changes from standardize_mol() with rule_name identification where possible"
    - "Existing API consumers without include_provenance receive identical responses (provenance is null)"
  artifacts:
    - path: "backend/app/services/standardization/provenance.py"
      provides: "ProvenancePipeline wrapper with per-stage diff capture"
      contains: "class ProvenancePipeline"
    - path: "backend/app/services/standardization/fragment_dict.py"
      provides: "COUNTERION_NAMES dictionary and classify_fragment() function"
      contains: "COUNTERION_NAMES"
    - path: "backend/app/schemas/standardization.py"
      provides: "Provenance Pydantic models and extended StandardizationOptions/Result"
      contains: "class StandardizationProvenance"
    - path: "backend/tests/test_standardization/test_provenance.py"
      provides: "Tests for provenance pipeline, fragment dict, and route integration"
      min_lines: 150
  key_links:
    - from: "backend/app/api/routes/standardization.py"
      to: "backend/app/services/standardization/provenance.py"
      via: "ProvenancePipeline called when include_provenance=True"
      pattern: "ProvenancePipeline.*standardize_with_provenance"
    - from: "backend/app/services/standardization/provenance.py"
      to: "backend/app/services/standardization/fragment_dict.py"
      via: "classify_fragment() for removed fragment naming"
      pattern: "classify_fragment"
    - from: "backend/app/schemas/standardization.py"
      to: "backend/app/api/routes/standardization.py"
      via: "StandardizationProvenance used in response conversion"
      pattern: "StandardizationProvenance"
---

<objective>
Implement the backend provenance pipeline for standardization intelligence (Milestone 2.1).

Purpose: Users running standardization with `include_provenance=true` get structured, atom-level provenance records for each pipeline stage — tautomer canonicalization mapping (STD-01), neutralization charge changes (STD-02), functional group audit (STD-03), and parent extraction fragment naming (STD-04). All provenance is additive to the existing `StandardizationResult` — existing API consumers receive identical responses.

Output: ProvenancePipeline wrapper class, fragment dictionary, extended Pydantic schemas, updated route, comprehensive tests.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-standardization-intelligence/02-RESEARCH.md
@backend/app/services/standardization/chembl_pipeline.py
@backend/app/schemas/standardization.py
@backend/app/api/routes/standardization.py
@backend/app/services/standardization/stereo_tracker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: ProvenancePipeline, fragment dictionary, and schema extension</name>
  <files>
    backend/app/services/standardization/provenance.py
    backend/app/services/standardization/fragment_dict.py
    backend/app/schemas/standardization.py
    backend/app/services/standardization/chembl_pipeline.py
  </files>
  <action>
**1. Create `backend/app/services/standardization/fragment_dict.py`:**

Build a curated `COUNTERION_NAMES` dictionary keyed by canonical SMILES with `{name, role}` entries. Include ~25-30 common counterions, salts, and solvents from the research (chloride, bromide, sodium, potassium, calcium, magnesium, lithium, ammonium, water, methanol, ethanol, DMSO, DMF, acetonitrile, acetic acid, TFA, benzoic acid, sulfuric acid, p-toluenesulfonic acid, phosphoric acid, carbonic acid, oxide, hydroxide, etc.).

Implement `classify_fragment(smiles: str) -> dict` that:
- Takes a SMILES string, canonicalizes it via `Chem.MolToSmiles(Chem.MolFromSmiles(smiles))`
- Looks up in `COUNTERION_NAMES` for name and role
- Falls back to `{"name": None, "role": "unknown"}` for unrecognized fragments
- Computes MW via `rdMolDescriptors.CalcExactMolWt()` after `Chem.SanitizeMol()` (try/except fallback to 0.0)
- Returns `{"smiles": canonical, "name": name_or_null, "role": role, "mw": float}`

**2. Create `backend/app/services/standardization/provenance.py`:**

Build `ProvenancePipeline` class that wraps the existing `StandardizationPipeline` stage-by-stage to capture atom-level diffs. Do NOT modify `StandardizationPipeline` internals — the wrapper re-calls the same underlying ChEMBL functions (`checker.check_molblock`, `standardizer.standardize_mol`, `get_parent_mol`) and captures state at each boundary.

Key methods:
- `standardize_with_provenance(mol, options) -> tuple[StandardizationResult, StandardizationProvenance]`: Runs the full pipeline, capturing per-stage provenance records.
- `_capture_checker_provenance(mol) -> ProvStageRecord`: Returns checker issues as changes.
- `_capture_standardizer_provenance(mol) -> tuple[Chem.Mol, ProvStageRecord]`: Calls `standardizer.standardize_mol(mol)`. Compares atom-by-atom: `GetFormalCharge()`, `GetNumRadicalElectrons()`, `GetIsAromatic()` before/after. Only valid when `before.GetNumAtoms() == after.GetNumAtoms()` (atom count preserved for charge/radical/aromaticity fixes). Reports charge changes as `ChargeChange` records (atom_idx, element, before_charge, after_charge). For functional group audit (STD-03): compare bonds, radical states, and aromaticity; identify rule_name via a curated `NORMALIZE_RULE_NAMES` lookup dict covering ~15 common transforms (nitro_normalization, sulphoxide_normalization, azide_normalization, etc.). Unmatched changes get `rule_name: "unknown_normalization"`.
- `_capture_get_parent_provenance(mol) -> tuple[Chem.Mol, ProvStageRecord, list[str]]`: Calls `get_parent_mol(mol)`. Uses SMILES fragment diffing (`set(before.split('.')) - set(after.split('.'))`) to find removed fragments. Classifies each via `classify_fragment()`. Does NOT use atom-idx comparison (atom count changes after fragment removal — per research pitfall).
- `_capture_tautomer_provenance(mol) -> tuple[Chem.Mol, ProvStageRecord, TautomerProvenance]`: Calls `TautomerEnumerator.Enumerate(mol)` first to get `modifiedAtoms`, `modifiedBonds`, tautomer count. Then calls `enumerator.Canonicalize(mol)` for the canonical form. Detects stereo stripping by comparing `FindMolChiralCenters()` before/after. Returns `TautomerProvenance` with `input_smiles`, `canonical_smiles`, `num_tautomers_enumerated`, `modified_atoms`, `modified_bonds`, `stereo_stripped`. If tautomer count > 100, set `complexity_flag: true`. Does NOT include all tautomer SMILES (per pitfall: response bloat). Uses `result.tautomers` (Python-iterable Mol objects), NOT `result.smiles` (C++ vector — per pitfall).

Build a curated `NORMALIZE_RULE_NAMES` dict mapping (element, change_type) patterns to human-readable rule names. Cover: nitro group normalization, sulphoxide normalization, azide normalization, diazo normalization, carboxylic acid normalization, amine neutralization, phosphate normalization. Provide both `rule_name` and `smarts` for each entry. For changes that don't match any known pattern, use `rule_name: "unknown_normalization", smarts: ""`.

**3. Extend `backend/app/schemas/standardization.py`:**

Add the following Pydantic models (all additive — do NOT modify existing models):
- `ChargeChange(BaseModel)`: atom_idx: int, element: str, before_charge: int, after_charge: int, rule_name: str, smarts: str
- `BondChange(BaseModel)`: bond_idx: int, atom1_idx: int, atom2_idx: int, before_type: str, after_type: str, rule_name: str
- `RadicalChange(BaseModel)`: atom_idx: int, element: str, before_radicals: int, after_radicals: int
- `FragmentRemoval(BaseModel)`: smiles: str, name: Optional[str] = None, role: Literal["salt", "solvent", "counterion", "unknown"], mw: float
- `TautomerProvenance(BaseModel)`: input_smiles: str, canonical_smiles: str, num_tautomers_enumerated: int, modified_atoms: List[int], modified_bonds: List[int], stereo_stripped: bool, complexity_flag: bool = False
- `ProvStageRecord(BaseModel)`: stage_name: str, input_smiles: str, output_smiles: str, applied: bool, charge_changes: List[ChargeChange] = [], bond_changes: List[BondChange] = [], radical_changes: List[RadicalChange] = [], fragment_removals: List[FragmentRemoval] = [], dval_cross_refs: List[str] = []
- `StereoProvenance(BaseModel)`: stereo_stripped: bool, centers_lost: int, bonds_lost: int, per_center: List[dict] = [] (placeholder for STD-06 in Plan 02)
- `StandardizationProvenance(BaseModel)`: stages: List[ProvStageRecord], tautomer: Optional[TautomerProvenance] = None, stereo_summary: Optional[StereoProvenance] = None

Extend EXISTING models (additive only):
- `StandardizationOptions`: add `include_provenance: bool = Field(default=False, description="Include detailed provenance records for each pipeline stage")`
- `StandardizationResult`: add `provenance: Optional[StandardizationProvenance] = Field(None, description="Detailed provenance when requested")`

Use separate typed fields per stage (`charge_changes`, `bond_changes`, `radical_changes`, `fragment_removals`) instead of a generic `changes: List[dict]` — per research recommendation to avoid TypeScript `any[]` issues.

**4. Update `backend/app/api/routes/standardization.py`:**

- Import `ProvenancePipeline` from `provenance.py`
- Create a singleton `_provenance_pipeline = ProvenancePipeline()` alongside existing `_pipeline`
- In `standardize_molecule()`: when `body.options.include_provenance` is True, call `_provenance_pipeline.standardize_with_provenance()` instead of `_pipeline.standardize()`. Pass `include_provenance=True` to the internal options.
- Update `_convert_pipeline_result()` to accept an optional `provenance` parameter. When provenance is provided, populate `result.provenance` with the `StandardizationProvenance` schema object.
- Keep the existing path (when `include_provenance=False`) completely unchanged — zero behavioral difference for existing consumers.

**5. Minimal touch to `chembl_pipeline.py`:**

Add `include_provenance: bool = False` to the `StandardizationOptions` dataclass. No other changes to this file. The `ProvenancePipeline` wrapper handles all provenance logic externally.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -c "from app.services.standardization.provenance import ProvenancePipeline; from app.services.standardization.fragment_dict import COUNTERION_NAMES, classify_fragment; from app.schemas.standardization import StandardizationProvenance, ChargeChange, FragmentRemoval, TautomerProvenance, ProvStageRecord; print(f'OK: ProvenancePipeline loaded, {len(COUNTERION_NAMES)} counterions, all schemas imported')"</automated>
    <manual>Verify that importing all new modules succeeds and the fragment dictionary has reasonable size</manual>
  </verify>
  <done>ProvenancePipeline class wraps ChEMBL pipeline with per-stage atom-level diff capture. Fragment dictionary classifies ~25 common counterions/salts/solvents. Pydantic schemas define all provenance models. Route conditionally calls provenance pipeline when include_provenance=True. Existing API behavior unchanged when provenance not requested.</done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive provenance tests</name>
  <files>
    backend/tests/test_standardization/test_provenance.py
  </files>
  <action>
Create `backend/tests/test_standardization/test_provenance.py` with comprehensive tests covering all four STD requirements:

**TestFragmentDictionary (~6 tests):**
- `test_common_counterions_present`: Verify chloride, sodium, bromide, potassium are in COUNTERION_NAMES
- `test_common_solvents_present`: Verify water, methanol, ethanol, DMSO are in COUNTERION_NAMES
- `test_common_salts_present`: Verify acetic acid, TFA, benzoic acid are in COUNTERION_NAMES
- `test_classify_known_fragment`: classify_fragment("[Cl-]") returns name="chloride", role="counterion", mw > 0
- `test_classify_unknown_fragment`: classify_fragment("CCCC") returns name=None, role="unknown", mw > 0
- `test_classify_invalid_smiles`: classify_fragment("invalid") returns graceful fallback with mw=0.0

**TestProvenancePipeline (~12 tests):**
- `test_basic_provenance_structure`: Standardize "CCO" with provenance, verify stages list has 3-4 entries with stage_name, input_smiles, output_smiles, applied
- `test_neutralization_charge_tracking` (STD-02): Standardize "[NH3+]CC([O-])=O" (alanine zwitterion), verify charge_changes list has entries with atom_idx, element, before_charge != after_charge
- `test_neutralization_charge_fields` (STD-02): Verify each ChargeChange has all required fields: atom_idx, element, before_charge, after_charge, rule_name, smarts
- `test_fragment_removal_tracking` (STD-04): Standardize "c1ccccc1.Cl" (benzene + HCl salt), verify get_parent stage has fragment_removals with smiles, name, role, mw fields
- `test_fragment_removal_named` (STD-04): Standardize molecule with known counterion (e.g. "[Na+].OC(=O)c1ccccc1"), verify removed fragment has name from dictionary
- `test_fragment_removal_unknown` (STD-04): Standardize molecule with uncommon fragment, verify role="unknown" and name=None
- `test_tautomer_provenance` (STD-01): Standardize "OC1=CC=CC=N1" (2-hydroxypyridine) with include_tautomer=True and include_provenance=True, verify tautomer provenance has input_smiles, canonical_smiles, num_tautomers_enumerated > 0, modified_atoms is list, stereo_stripped is bool
- `test_tautomer_provenance_stereo_stripping` (STD-01): Use a molecule with defined stereo that gets stripped during tautomer canonicalization, verify stereo_stripped=True
- `test_functional_group_audit` (STD-03): Standardize a molecule with nitro group or sulphoxide that gets normalized, verify bond_changes or charge_changes contain entries with rule_name
- `test_no_provenance_when_not_requested`: Standardize "CCO" without include_provenance, verify provenance is None
- `test_provenance_backward_compatible`: Verify StandardizationResult without provenance matches the same structure as v1 (provenance field is None/absent)
- `test_none_molecule_handling`: ProvenancePipeline handles None mol gracefully

**TestProvenanceEndpoint (~4 tests):**
- `test_endpoint_with_provenance`: POST /api/v1/standardize with include_provenance=true, verify response has result.provenance with stages array
- `test_endpoint_without_provenance`: POST /api/v1/standardize without provenance flag, verify result.provenance is null
- `test_endpoint_provenance_neutralization`: POST with charged molecule + provenance, verify charge_changes in standardizer stage
- `test_endpoint_provenance_fragment_removal`: POST with salt-containing molecule + provenance, verify fragment_removals in get_parent stage

Use pytest fixtures for common molecule creation. Follow existing test patterns from `test_chembl_pipeline.py` and `test_endpoint.py`. All tests should use the conda cheminformatics environment's RDKit.

Target: ~22 tests total.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -m pytest tests/test_standardization/test_provenance.py -v --tb=short 2>&1 | tail -30</automated>
    <manual>All tests pass. No existing tests broken.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>All ~22 provenance tests pass covering fragment dictionary lookup (STD-04), charge tracking (STD-02), functional group audit (STD-03), tautomer provenance (STD-01), backward compatibility, and endpoint integration. No existing standardization tests broken.</done>
</task>

</tasks>

<verification>
1. `python -c "from app.services.standardization.provenance import ProvenancePipeline"` succeeds
2. `python -c "from app.schemas.standardization import StandardizationProvenance, ChargeChange, FragmentRemoval, TautomerProvenance"` succeeds
3. `pytest tests/test_standardization/test_provenance.py -v` — all tests pass
4. `pytest tests/test_standardization/ -v` — all existing tests still pass (backward compatibility)
5. `curl -X POST /api/v1/standardize -d '{"molecule": "[NH3+]CC([O-])=O", "options": {"include_provenance": true}}'` returns provenance with charge_changes
6. `curl -X POST /api/v1/standardize -d '{"molecule": "CCO"}'` returns provenance: null (backward compatible)
</verification>

<success_criteria>
- ProvenancePipeline produces per-stage provenance for all 4 pipeline stages
- Charged molecules report atom-level charge changes (STD-02)
- Salt-containing molecules report named fragment removals (STD-04)
- Tautomer provenance includes modified_atoms, modified_bonds, stereo_stripped (STD-01)
- Functional group normalization reports rule names where identifiable (STD-03)
- Existing API consumers unaffected (provenance defaults to null)
- All new tests pass, all existing tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/02-standardization-intelligence/02-01-SUMMARY.md`
</output>
