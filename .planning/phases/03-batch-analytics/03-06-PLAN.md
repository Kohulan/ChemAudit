---
phase: 03-batch-analytics
plan: 06
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/services/analytics/statistics.py
  - backend/tests/test_analytics_statistics.py
autonomous: true
requirements:
  - BATCH-16
  - BATCH-17
  - BATCH-18
  - BATCH-19

must_haves:
  truths:
    - "Property distribution statistics return mean, median, std, quartiles, IQR, min, max per property"
    - "Property correlation matrix returns pairwise Pearson correlations for all numeric properties"
    - "Batch quality score is a composite 0-100 metric with 40% validity, 35% diversity (scaffold entropy), and 25% drug-likeness (Lipinski pass rate)"
    - "IQR-based outlier detection flags molecules with property values outside [Q1-1.5*IQR, Q3+1.5*IQR]"
    - "compute_all_statistics returns a dict combining property_stats, correlations, outliers, and quality_score"
  artifacts:
    - path: "backend/app/services/analytics/statistics.py"
      provides: "Property stats, correlation matrix, quality score, outlier detection"
      exports: ["compute_all_statistics"]
    - path: "backend/tests/test_analytics_statistics.py"
      provides: "Tests for statistics, correlations, quality score, and outlier detection"
      min_lines: 80
  key_links:
    - from: "backend/app/services/batch/analytics_tasks.py"
      to: "backend/app/services/analytics/statistics.py"
      via: "import compute_all_statistics in run_cheap_analytics"
      pattern: "from app\\.services\\.analytics\\.statistics import"
---

<objective>
Implement batch statistics: property distribution statistics, correlation matrix, composite batch quality score, and IQR-based outlier detection.

Purpose: Statistics (with quality score and outliers) are auto-computed at batch completion (cheap analytics). They provide immediate quantitative assessment of batch quality and flag problematic molecules.

Output: `statistics.py` service with stats, correlations, quality score, and outlier detection, fully tested.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-batch-analytics/03-RESEARCH.md
@.planning/phases/03-batch-analytics/03-01-SUMMARY.md

@backend/app/schemas/analytics.py
@backend/app/services/batch/result_aggregator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Statistics, Quality Score, and Outlier Service</name>
  <files>backend/app/services/analytics/statistics.py</files>
  <action>
Create `backend/app/services/analytics/statistics.py`:

**Property extraction constants:**
```python
# Properties to extract from batch results for statistical analysis
PROPERTY_EXTRACTORS = {
    "validation_score": lambda r: (r.get("validation") or {}).get("overall_score"),
    "qed_score": lambda r: ((r.get("scoring") or {}).get("druglikeness") or {}).get("qed_score"),
    "sa_score": lambda r: ((r.get("scoring") or {}).get("admet") or {}).get("sa_score"),
    "ml_readiness_score": lambda r: ((r.get("scoring") or {}).get("ml_readiness") or {}).get("score"),
    "fsp3": lambda r: ((r.get("scoring") or {}).get("admet") or {}).get("fsp3"),
}
```

**_extract_property_values(results: list[dict], prop_name: str, extractor) -> list[tuple[int, float]]**:
- For each successful result, extract value using extractor.
- Return list of (molecule_index, value) tuples where value is not None.

**compute_property_stats(results: list[dict]) -> list[dict]**:
- For each property in PROPERTY_EXTRACTORS:
  - Extract values.
  - If fewer than 2 values, skip this property.
  - Compute using numpy: `mean, median, std = np.mean(vals), np.median(vals), np.std(vals, ddof=1)`.
  - Compute `q1, q3 = np.percentile(vals, [25, 75])`, `iqr = q3 - q1`.
  - Compute `min_val, max_val = np.min(vals), np.max(vals)`.
  - Return dict matching `PropertyStats` schema.

**compute_correlations(results: list[dict]) -> list[dict]**:
- Extract all properties into a dict of {prop_name: np.array}.
- Only include properties with ≥10 values.
- For each pair of properties: compute Pearson correlation via `np.corrcoef(arr_a, arr_b)[0, 1]`.
  - Handle NaN: if corrcoef returns NaN (constant array), set pearson_r = 0.0.
- Return list of dicts matching `PropertyCorrelation` schema.
- Only include pairs where abs(pearson_r) > 0 (skip zero correlations for brevity).

**compute_outliers(results: list[dict]) -> list[dict]**:
- For each property in PROPERTY_EXTRACTORS:
  - Extract (index, value) tuples.
  - If fewer than 4 values, skip.
  - Compute IQR fences: `lower = q1 - 1.5 * iqr`, `upper = q3 + 1.5 * iqr`.
  - Flag values outside fences.
  - Return list of dicts matching `OutlierInfo` schema: `{"molecule_index": int, "property_name": str, "value": float, "lower_fence": float, "upper_fence": float}`.

**compute_quality_score(results: list[dict]) -> dict**:
- **Validity (40%)**: `successful / total * 100` where successful = results with status="success", total = len(results).
- **Diversity (35%)**: Compute inline Murcko scaffold entropy (import `MurckoScaffold` from rdkit).
  - For each successful molecule: extract scaffold via `MurckoScaffold.GetScaffoldForMol(mol)`.
  - Compute Shannon entropy of scaffold frequency distribution.
  - Normalize: `diversity_pct = (entropy / log2(unique_scaffolds)) * 100` if unique_scaffolds > 1, else 0.
  - This inline scaffold extraction is cheap (O(n)) and does NOT depend on the scaffold analysis service.
- **Drug-likeness (25%)**: Count molecules with `lipinski_passed=True` in scoring results. `druglikeness_pct = lipinski_passes / lipinski_total * 100`.
  - If no lipinski data available, fall back to 50% (neutral contribution).
- **Composite**: `score = validity_pct * 0.40 + diversity_pct * 0.35 + druglikeness_pct * 0.25`.
- Round all values to 1 decimal place.
- Return dict matching `QualityScore` schema.

**compute_all_statistics(results: list[dict]) -> dict**:
- Call compute_property_stats, compute_correlations, compute_outliers, compute_quality_score.
- Return dict matching `StatisticsResult` schema: `{"property_stats": [...], "correlations": [...], "outliers": [...], "quality_score": {...}}`.

Include module docstring, function docstrings, type hints, and numpy import.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -c "from app.services.analytics.statistics import compute_all_statistics; print('Import OK')"</automated>
  </verify>
  <done>Statistics service computes property distributions, Pearson correlations, IQR outliers, and composite quality score (40/35/25 weighting)</done>
</task>

<task type="auto">
  <name>Task 2: Statistics and Quality Score Tests</name>
  <files>backend/tests/test_analytics_statistics.py</files>
  <action>
Create `backend/tests/test_analytics_statistics.py`:

1. **test_property_stats_basic**: Batch of 10 molecules with known QED scores → mean, median, std are within expected ranges.

2. **test_property_stats_all_properties**: Verify all 5 properties in PROPERTY_EXTRACTORS produce stats when data available.

3. **test_property_stats_skip_insufficient**: Only 1 value for a property → that property is skipped.

4. **test_correlations_positive**: Batch where validation_score and ml_readiness are correlated → pearson_r is positive.

5. **test_correlations_nan_handling**: Property with constant value (all same QED) → pearson_r = 0.0 (not NaN).

6. **test_correlations_insufficient_data**: Fewer than 10 data points for a property → excluded from correlation.

7. **test_outlier_detection_basic**: Batch with one extreme value (e.g., QED=0.01 when others are 0.5-0.9) → flagged as outlier.

8. **test_outlier_detection_no_outliers**: Normally distributed values → no outliers flagged.

9. **test_outlier_detection_insufficient**: Fewer than 4 values → no outliers computed.

10. **test_quality_score_perfect_batch**: All valid, diverse scaffolds, all pass Lipinski → score near 100.

11. **test_quality_score_poor_batch**: Many errors, single scaffold, low Lipinski pass rate → score well below 50.

12. **test_quality_score_validity_weight**: Batch with 50% errors → validity component = 50, contributing 0.4 * 50 = 20 to composite.

13. **test_quality_score_diversity_single_scaffold**: All same scaffold → diversity = 0, contributing 0 to composite.

14. **test_quality_score_no_lipinski_data**: No Lipinski data → drug-likeness defaults to 50%.

15. **test_compute_all_statistics**: Full integration — returns dict with all 4 keys populated.

16. **test_empty_batch**: Empty results → property_stats=[], correlations=[], outliers=[], quality_score has 0 for everything.

Use helper `_make_result_with_scores(smiles, index, validation_score, qed, lipinski_passed, sa_score=None, fsp3=None)` that builds result dict with nested scoring structure.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -m pytest tests/test_analytics_statistics.py -x -v</automated>
  </verify>
  <done>16+ tests pass covering property stats, correlations, outlier detection, quality score weighting, edge cases, and the all-statistics aggregator</done>
</task>

</tasks>

<verification>
1. `compute_all_statistics` returns StatisticsResult-compatible dict
2. Property stats use numpy (not hand-coded math)
3. Correlations handle NaN (constant arrays) gracefully
4. IQR outlier fences correctly computed: lower = Q1-1.5*IQR, upper = Q3+1.5*IQR
5. Quality score weighting: 40% validity, 35% diversity, 25% drug-likeness
6. Quality score diversity uses inline scaffold extraction (no dependency on scaffold_analysis service)
7. Empty batch produces valid response (not crash)
8. All tests pass
</verification>

<success_criteria>
- BATCH-16 through BATCH-19 fully implemented
- Statistics service importable by analytics_tasks.py run_cheap_analytics
- Quality score produces composite 0-100 metric
- Outliers correctly flagged with IQR method
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-analytics/03-06-SUMMARY.md`
</output>
