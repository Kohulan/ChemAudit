---
phase: 03-batch-analytics
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/services/analytics/scaffold_analysis.py
  - backend/tests/test_analytics_scaffold.py
autonomous: true
requirements:
  - BATCH-05
  - BATCH-06
  - BATCH-07
  - BATCH-08

must_haves:
  truths:
    - "Murcko scaffold is extracted for each molecule and molecules are grouped by scaffold SMILES"
    - "Generic scaffold (element-agnostic) is extracted using MakeScaffoldGeneric + second GetScaffoldForMol call"
    - "Shannon entropy diversity metric is computed from scaffold frequency distribution"
    - "R-group decomposition accepts a user-specified SMARTS core and returns per-molecule R-groups"
    - "Invalid SMARTS core for R-group returns a no_matches result instead of crashing"
  artifacts:
    - path: "backend/app/services/analytics/scaffold_analysis.py"
      provides: "Scaffold decomposition, grouping, diversity metrics, R-group decomposition"
      exports: ["compute_scaffold_analysis", "compute_rgroup_decomposition"]
    - path: "backend/tests/test_analytics_scaffold.py"
      provides: "Tests for scaffold analysis and R-group decomposition"
      min_lines: 60
  key_links:
    - from: "backend/app/services/batch/analytics_tasks.py"
      to: "backend/app/services/analytics/scaffold_analysis.py"
      via: "import compute_scaffold_analysis in run_expensive_analytics scaffold branch"
      pattern: "from app\\.services\\.analytics\\.scaffold_analysis import"
---

<objective>
Implement scaffold analysis: Murcko decomposition, generic scaffold grouping, diversity metrics, and R-group decomposition around user-specified cores.

Purpose: Scaffold analysis is a user-triggered expensive analytics type. It reveals structural diversity in the batch, groups molecules by structural family, and enables R-group SAR exploration.

Output: `scaffold_analysis.py` service with scaffold grouping + R-group decomposition, fully tested.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-batch-analytics/03-RESEARCH.md
@.planning/phases/03-batch-analytics/03-01-SUMMARY.md

@backend/app/services/scoring/scaffold.py
@backend/app/schemas/analytics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold Analysis Service</name>
  <files>backend/app/services/analytics/scaffold_analysis.py</files>
  <action>
Create `backend/app/services/analytics/scaffold_analysis.py`:

1. **compute_scaffold_analysis(results: list[dict]) -> dict**:
   - Import `MurckoScaffold` from `rdkit.Chem.Scaffolds`.
   - For each successful result, parse SMILES, extract Murcko scaffold via `MurckoScaffold.GetScaffoldForMol(mol)`.
   - For generic scaffold: call `MurckoScaffold.MakeScaffoldGeneric(scaffold_mol)`, then `MurckoScaffold.GetScaffoldForMol(generic_mol)` (double-call pattern to remove converted exocyclic substituents, per existing `app/services/scoring/scaffold.py`).
   - Group molecules by scaffold SMILES. Each group: `{"scaffold_smiles": str, "generic_scaffold_smiles": str, "molecule_indices": list[int], "count": int}`.
   - Sort groups by count descending.
   - Compute **unique_scaffold_count** = number of distinct scaffolds.
   - Compute **Shannon entropy**: For each scaffold with frequency f_i and total N: `entropy = -sum((f_i/N) * log2(f_i/N))`. Use `math.log2`. Handle edge case: if only 1 scaffold, entropy = 0.
   - Compute **frequency_distribution**: dict mapping scaffold_smiles to count, capped at top 50 scaffolds + "Other" bucket for remainder.
   - Molecules with no ring system (acyclic): scaffold = "" (empty string group).
   - Return dict matching `ScaffoldResult` schema.

2. **compute_rgroup_decomposition(results: list[dict], core_smarts: str) -> dict**:
   - Validate core SMARTS: `core = Chem.MolFromSmarts(core_smarts)`. If None, return `{"core_smarts": core_smarts, "decomposition": [], "unmatched_count": len(results), "error": "Invalid SMARTS pattern"}`.
   - Use `from rdkit.Chem import rdRGroupDecomposition`.
   - Parse all successful molecules into a list.
   - Call `rdRGroupDecomposition.RGroupDecompose([core], mols, asSmiles=True)`.
   - The return value is `(match_info, results_list)`. `match_info` contains matched indices.
   - Build decomposition list: for each matched molecule, dict with `{"molecule_index": int, "core": core_smarts, "rgroups": {"R1": smiles, "R2": smiles, ...}}`.
   - Count unmatched = total - matched.
   - Return dict matching `RGroupResult` schema: `{"core_smarts": core_smarts, "decomposition": [...], "unmatched_count": N}`.
   - If `RGroupDecompose` raises exception, return result with empty decomposition and error message.

Include proper imports, docstrings, type hints, and logging for edge cases.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -c "from app.services.analytics.scaffold_analysis import compute_scaffold_analysis, compute_rgroup_decomposition; print('Import OK')"</automated>
  </verify>
  <done>Scaffold analysis service computes Murcko + generic scaffolds, groups molecules, calculates Shannon entropy, and performs R-group decomposition</done>
</task>

<task type="auto">
  <name>Task 2: Scaffold Analysis Tests</name>
  <files>backend/tests/test_analytics_scaffold.py</files>
  <action>
Create `backend/tests/test_analytics_scaffold.py`:

1. **test_scaffold_groups_benzene_derivatives**: Batch with toluene ("Cc1ccccc1"), aniline ("Nc1ccccc1"), phenol ("Oc1ccccc1") → all share benzene scaffold "c1ccccc1"; group count = 3.

2. **test_scaffold_different_scaffolds**: Batch with benzene ring molecule and pyridine ring molecule → two distinct scaffold groups.

3. **test_generic_scaffold**: Two molecules with same ring topology but different heteroatoms → same generic scaffold SMILES.

4. **test_acyclic_molecules**: Ethanol ("CCO"), butane ("CCCC") → grouped under empty scaffold "".

5. **test_scaffold_shannon_entropy_single**: All same scaffold → entropy = 0.

6. **test_scaffold_shannon_entropy_diverse**: N distinct scaffolds with equal frequency → entropy = log2(N).

7. **test_scaffold_frequency_distribution_cap**: >50 scaffolds → frequency_distribution has 50 entries + "Other".

8. **test_rgroup_decomposition_basic**: Batch of substituted benzenes with core "[*]c1ccccc1" → each molecule decomposes with R1 substituent.

9. **test_rgroup_invalid_smarts**: Invalid SMARTS string → returns error dict, no crash.

10. **test_rgroup_no_matches**: Valid SMARTS that matches nothing → unmatched_count equals total molecules.

11. **test_scaffold_empty_batch**: Empty results → empty scaffolds list, entropy = 0.

Use helper `_make_result(smiles, index)` to build test result dicts.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -m pytest tests/test_analytics_scaffold.py -x -v</automated>
  </verify>
  <done>11+ tests pass covering scaffold grouping, generic scaffolds, Shannon entropy, frequency cap, R-group decomposition, and edge cases</done>
</task>

</tasks>

<verification>
1. `compute_scaffold_analysis` returns ScaffoldResult-compatible dict
2. Generic scaffold uses double-GetScaffoldForMol pattern (per existing scaffold.py)
3. Shannon entropy calculation handles edge cases (single scaffold, empty batch)
4. Frequency distribution capped at 50 + "Other"
5. R-group decomposition validates SMARTS before calling RGroupDecompose
6. All tests pass
</verification>

<success_criteria>
- BATCH-05 through BATCH-08 fully implemented
- Scaffold service importable by analytics_tasks.py run_expensive_analytics
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-analytics/03-03-SUMMARY.md`
</output>
