---
phase: 03-batch-analytics
plan: 05
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/services/analytics/mmp.py
  - backend/tests/test_analytics_mmp.py
autonomous: true
requirements:
  - BATCH-13
  - BATCH-14
  - BATCH-15

must_haves:
  truths:
    - "MMP detection uses BRICS single-cut fragmentation to find molecule pairs sharing a common core with different R-groups"
    - "MMP computation enforces a batch size limit of 5000 molecules; larger batches are refused"
    - "Activity cliff detection computes SALI index (|delta_activity| / (1 - Tanimoto)) for each MMP pair"
    - "Activity cliff and LLE computations require an activity_column parameter; if absent, they are skipped with a descriptive reason"
    - "LLE is computed as pIC50 - LogP for each molecule when activity data is provided"
  artifacts:
    - path: "backend/app/services/analytics/mmp.py"
      provides: "MMP detection, activity cliff detection, LLE computation"
      exports: ["compute_mmp_analysis"]
    - path: "backend/tests/test_analytics_mmp.py"
      provides: "Tests for MMP, activity cliffs, and LLE"
      min_lines: 60
  key_links:
    - from: "backend/app/services/batch/analytics_tasks.py"
      to: "backend/app/services/analytics/mmp.py"
      via: "import compute_mmp_analysis in run_expensive_analytics mmp branch"
      pattern: "from app\\.services\\.analytics\\.mmp import"
---

<objective>
Implement Matched Molecular Pair (MMP) detection, activity cliff identification (SALI index), and Lipophilic Ligand Efficiency (LLE) computation.

Purpose: MMP analysis is a user-triggered expensive analytics type. It reveals structure-activity relationships by finding molecule pairs that differ by a single structural transformation. Activity cliffs and LLE require user-supplied activity data.

Output: `mmp.py` service with MMP detection, SALI-based activity cliffs, and LLE computation, fully tested.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-batch-analytics/03-RESEARCH.md
@.planning/phases/03-batch-analytics/03-01-SUMMARY.md

@backend/app/schemas/analytics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: MMP, Activity Cliff, and LLE Service</name>
  <files>backend/app/services/analytics/mmp.py</files>
  <action>
Create `backend/app/services/analytics/mmp.py`:

**Module-level setup:**
- Import `rdkit.Chem.BRICS`, `rdkit.Chem.rdFMCS`, `rdkit.Chem.rdFingerprintGenerator`, `rdkit.DataStructs`, `rdkit.Chem.Descriptors`.
- Morgan fingerprint generator (same pattern as chemical_space.py): `_morgan_gen = rdFingerprintGenerator.GetMorganGenerator(radius=2, fpSize=2048)`.
- MAX_MMP_BATCH_SIZE = 5000.

**_detect_mmp_pairs(mols: list[Chem.Mol], indices: list[int]) -> list[dict]**:
- For each molecule, compute BRICS fragments via `BRICS.BRICSDecompose(mol)`.
- Build a fragment-to-molecules mapping: `{fragment_smiles: [(mol_index, remaining_fragment_smiles), ...]}`.
- For each fragment that maps to 2+ molecules, those molecules form MMP pairs (shared core, different R-groups).
- To reduce noise: only consider fragment pairs where the shared fragment is the larger piece (core). Use a size heuristic: shared fragment must have more heavy atoms than the variable fragment.
- For each pair, compute Tanimoto similarity between the two molecules' Morgan fingerprints.
- Return list of dicts matching `MMPPair` schema: `{"mol_a_index": int, "mol_b_index": int, "core_smiles": str, "rgroup_a": str, "rgroup_b": str, "tanimoto": float}`.
- Deduplicate pairs: each (mol_a, mol_b) appears at most once (keep highest Tanimoto if multiple cores match).
- Limit output to 1000 pairs max (sorted by Tanimoto descending) to prevent massive responses.

**_compute_activity_cliffs(pairs: list[dict], activities: dict[int, float]) -> list[dict]**:
- For each MMP pair, look up activity for mol_a_index and mol_b_index in activities dict.
- If both have activity values: compute `sali = abs(act_a - act_b) / (1.0 - tanimoto)` if tanimoto < 1.0, else SALI = infinity (skip).
- Return list of dicts matching `ActivityCliff` schema, sorted by SALI descending.
- Skip pairs where either molecule lacks activity data.

**_compute_lle(results: list[dict], activity_column: str) -> list[dict]**:
- For each successful result with activity data: parse molecule, compute LogP via `Descriptors.MolLogP(mol)`.
- `lle = activity_value - logp` (assumes activity is pIC50 or similar -log scale).
- Return list of `{"molecule_index": int, "activity": float, "logp": float, "lle": float}`.

**compute_mmp_analysis(results: list[dict], activity_column: str | None = None) -> dict**:
- Enforce batch size: if len(successful results) > MAX_MMP_BATCH_SIZE, return `{"status": "refused", "reason": f"MMP detection limited to {MAX_MMP_BATCH_SIZE} molecules", "molecule_count": n}`.
- Parse all successful molecules into (mols, indices) lists.
- Call `_detect_mmp_pairs(mols, indices)`.
- If `activity_column` is provided:
  - Extract activity values from each result's `properties` dict using `activity_column` key. Parse to float, skip if missing/unparseable.
  - Build `activities: dict[int, float]` mapping index → activity value.
  - If activities dict is empty, return pairs with `activity_cliffs=None, lle_values=None` and a note "No valid activity values found in column '{activity_column}'".
  - Otherwise: compute activity cliffs and LLE.
- If `activity_column` is None: set `activity_cliffs=None, lle_values=None`.
- Return dict matching `MMPResult` schema: `{"pairs": [...], "activity_cliffs": [...] or None, "lle_values": [...] or None}`.

Include module docstring explaining MMP, SALI, and LLE concepts. Include logging for timing.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -c "from app.services.analytics.mmp import compute_mmp_analysis; print('Import OK')"</automated>
  </verify>
  <done>MMP service detects molecular pairs via BRICS fragmentation, computes SALI activity cliffs, and calculates LLE when activity data provided</done>
</task>

<task type="auto">
  <name>Task 2: MMP, Activity Cliff, and LLE Tests</name>
  <files>backend/tests/test_analytics_mmp.py</files>
  <action>
Create `backend/tests/test_analytics_mmp.py`:

1. **test_mmp_finds_pairs**: Batch containing two molecules differing by one substituent (e.g., "c1ccccc1O" and "c1ccccc1N" — phenol and aniline) → at least one MMP pair detected with core containing benzene.

2. **test_mmp_no_pairs**: Batch of structurally unrelated molecules (ethanol, benzene, aspirin) → no or very few MMP pairs.

3. **test_mmp_refuses_large_batch**: Batch of 5001 result dicts → returns "refused" status.

4. **test_mmp_tanimoto_computed**: MMP pair has a tanimoto value between 0 and 1.

5. **test_mmp_pair_deduplication**: Same molecule pair should appear at most once in results.

6. **test_mmp_pairs_limited**: Very large set of related molecules → output capped at 1000 pairs.

7. **test_activity_cliffs_with_data**: Batch with activity column → activity_cliffs list populated with SALI values.

8. **test_activity_cliffs_without_column**: No activity_column → activity_cliffs is None.

9. **test_activity_cliffs_missing_values**: Some molecules lack activity → only pairs with both values computed.

10. **test_lle_computation**: Molecule with activity=7.0 and LogP=2.0 → LLE = 5.0.

11. **test_lle_no_activity**: No activity_column → lle_values is None.

12. **test_mmp_empty_batch**: Empty results → pairs=[], no crash.

Use helper `_make_result_with_props(smiles, index, properties=None)` that includes properties dict for activity column access. For activity tests, set `properties={"pIC50": "7.5"}` in the result dict.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -m pytest tests/test_analytics_mmp.py -x -v</automated>
  </verify>
  <done>12+ tests pass covering MMP detection, pair deduplication, batch size limit, activity cliffs with SALI, LLE computation, and edge cases</done>
</task>

</tasks>

<verification>
1. `compute_mmp_analysis` returns MMPResult-compatible dict
2. Batch size limit of 5000 enforced
3. BRICS fragmentation used (not custom bond cutting)
4. Activity cliffs skip pairs where either molecule lacks activity
5. LLE = activity - LogP formula correct
6. MMP pairs deduplicated (each pair appears once)
7. All tests pass
</verification>

<success_criteria>
- BATCH-13 through BATCH-15 fully implemented
- MMP service importable by analytics_tasks.py
- Activity column is optional — graceful degradation when absent
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-analytics/03-05-SUMMARY.md`
</output>
