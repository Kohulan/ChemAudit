---
phase: 03-batch-analytics
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/services/analytics/deduplication.py
  - backend/tests/test_analytics_dedup.py
autonomous: true
requirements:
  - BATCH-01
  - BATCH-02
  - BATCH-03
  - BATCH-04

must_haves:
  truths:
    - "Exact duplicates are detected by grouping molecules with identical canonical SMILES"
    - "Tautomeric duplicates are detected by grouping molecules with identical canonical tautomer SMILES"
    - "Stereo-insensitive duplicates are detected by grouping molecules with identical stereo-stripped InChI"
    - "Salt-form duplicates are detected by grouping molecules by parent compound SMILES after desalting"
    - "Representative molecule per group is the one with the lowest original index (first submitted)"
    - "compute_all_dedup_levels returns a dict with keys exact, tautomeric, stereo_insensitive, salt_form and total_unique counts"
  artifacts:
    - path: "backend/app/services/analytics/deduplication.py"
      provides: "All 4 dedup levels and compute_all_dedup_levels aggregator"
      exports: ["compute_all_dedup_levels", "compute_exact_dedup", "compute_tautomer_dedup", "compute_stereo_dedup", "compute_saltform_dedup"]
    - path: "backend/tests/test_analytics_dedup.py"
      provides: "Tests for all 4 dedup levels"
      min_lines: 80
  key_links:
    - from: "backend/app/services/batch/analytics_tasks.py"
      to: "backend/app/services/analytics/deduplication.py"
      via: "import compute_all_dedup_levels in run_cheap_analytics"
      pattern: "from app\\.services\\.analytics\\.deduplication import"
---

<objective>
Implement multi-level duplicate detection across 4 levels: exact SMILES, tautomeric canonical, stereo-insensitive InChI, and salt-form parent.

Purpose: Deduplication is auto-computed at batch completion (cheap analytics) and surfaces duplicates across all 4 levels simultaneously per the user's locked decision. Each level is self-contained.

Output: `deduplication.py` service with 4 dedup functions + aggregator, fully tested.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-batch-analytics/03-RESEARCH.md
@.planning/phases/03-batch-analytics/03-01-SUMMARY.md

@backend/app/schemas/analytics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Multi-Level Deduplication Service</name>
  <files>backend/app/services/analytics/deduplication.py</files>
  <action>
Create `backend/app/services/analytics/deduplication.py` implementing 4 dedup levels:

1. **compute_exact_dedup(results: list[dict]) -> list[dict]**:
   - Skip results where `status != "success"`.
   - Parse each SMILES with `Chem.MolFromSmiles`, skip if None.
   - Generate canonical SMILES key via `Chem.MolToSmiles(mol)`.
   - Group by canonical key. For each group with >1 member, create a dedup group dict with: `level="exact"`, `representative_index=min(indices)`, `duplicate_indices=[sorted remaining]`, `group_key=canonical_smiles`, `count=len(indices)`.
   - CRITICAL: representative is `min(indices)` (first submitted), NOT `indices[0]` — because dict insertion order may not match submission order for parallel-processed chunks.

2. **compute_tautomer_dedup(results: list[dict]) -> list[dict]**:
   - Same pattern as exact, but key is `Chem.MolToSmiles(enumerator.Canonicalize(mol))`.
   - Instantiate `TautomerEnumerator()` locally per call (NOT module-level — not thread-safe per research Pitfall 7).
   - `from rdkit.Chem.MolStandardize import rdMolStandardize` for TautomerEnumerator.
   - If canonicalization raises, fall back to canonical SMILES for that molecule.

3. **compute_stereo_dedup(results: list[dict]) -> list[dict]**:
   - Same grouping pattern, but key is stereo-stripped InChI.
   - Use `from rdkit.Chem.inchi import MolToInchi`.
   - Strip stereo layers: `STEREO_LAYERS = frozenset(['t', 'm', 's'])`. Split InChI by '/', filter out parts starting with any stereo layer letter, rejoin.
   - If InChI generation fails for a molecule, skip it.

4. **compute_saltform_dedup(results: list[dict]) -> list[dict]**:
   - Key is canonical SMILES of parent compound after desalting.
   - Use `from chembl_structure_pipeline import standardize_mol` or directly `from chembl_structure_pipeline.standardizer import get_parent_mol`.
   - For each molecule: try `get_parent_mol(mol)`, get canonical SMILES of parent.
   - If standardization data exists in `result["standardization"]["standardized_smiles"]`, use that as a fast path. Otherwise call `get_parent_mol()` on-the-fly (per research Pitfall 1).
   - If parent extraction fails, fall back to original canonical SMILES.

5. **compute_all_dedup_levels(results: list[dict]) -> dict**:
   - Call all 4 functions.
   - Return dict matching `DeduplicationResult` schema: `{"exact": [...], "tautomeric": [...], "stereo_insensitive": [...], "salt_form": [...], "total_unique": {"exact": N, "tautomeric": N, "stereo_insensitive": N, "salt_form": N}}`.
   - `total_unique` per level = total successful molecules minus sum of duplicate counts (or count of unique groups).

Include module docstring, function docstrings with Args/Returns, and type hints throughout.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -c "from app.services.analytics.deduplication import compute_all_dedup_levels; print('Import OK')"</automated>
  </verify>
  <done>All 4 dedup functions implemented with correct representative selection (min index), thread-safe tautomer enumerator, stereo-stripped InChI, and on-the-fly salt-form desalting</done>
</task>

<task type="auto">
  <name>Task 2: Deduplication Tests</name>
  <files>backend/tests/test_analytics_dedup.py</files>
  <action>
Create `backend/tests/test_analytics_dedup.py` with comprehensive tests:

1. **test_exact_dedup_finds_duplicates**: Two identical SMILES ("CCO" appearing twice with different indices) → grouped as duplicates, representative is min index.

2. **test_exact_dedup_no_duplicates**: Three different molecules → no dedup groups returned.

3. **test_exact_dedup_canonical_normalization**: "C(O)C" and "CCO" are the same molecule (canonical: "CCO") → detected as duplicate pair.

4. **test_exact_dedup_skips_errors**: Results with `status="error"` are excluded from dedup.

5. **test_exact_dedup_representative_is_min_index**: Group of 3 duplicates with indices [5, 2, 8] → representative is 2.

6. **test_tautomer_dedup**: Two tautomers (e.g., "C=C(O)C" and "CC(=O)C" — keto-enol pair) → grouped as tautomeric duplicates.

7. **test_stereo_dedup**: "C[C@@H](O)F" and "C[C@H](O)F" → grouped as stereo-insensitive duplicates.

8. **test_stereo_dedup_different_molecules**: "CCO" and "CCCO" → NOT grouped.

9. **test_saltform_dedup**: "CCN.Cl" and "CCN" → grouped as salt-form duplicates (same parent: ethylamine).

10. **test_compute_all_dedup_levels**: Mixed batch with exact + tautomeric + stereo duplicates → all levels return correct groups, total_unique counts are correct.

11. **test_dedup_empty_batch**: Empty results list → all levels return empty lists.

12. **test_dedup_unparseable_smiles**: Results with invalid SMILES → skipped gracefully, no crash.

Use helper function `_make_result(smiles, index, status="success")` to create test result dicts matching the batch result format (must include "smiles", "index", "status", "standardization" keys).
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && /Users/kohulanrajan/anaconda3/envs/cheminformatics/bin/python -m pytest tests/test_analytics_dedup.py -x -v</automated>
  </verify>
  <done>12+ tests pass covering all 4 dedup levels, edge cases (empty, errors, unparseable), representative selection, and the all-levels aggregator</done>
</task>

</tasks>

<verification>
1. `compute_all_dedup_levels` returns dict with all 4 level keys + total_unique
2. Exact dedup correctly canonicalizes SMILES before comparison
3. Tautomeric dedup uses thread-local TautomerEnumerator (not module-level)
4. Stereo dedup strips /t, /m, /s layers from InChI
5. Salt-form dedup runs get_parent_mol on-the-fly when standardization data absent
6. Representative is always min(indices) in each group
7. Error results are excluded from all dedup levels
8. All tests pass
</verification>

<success_criteria>
- BATCH-01 through BATCH-04 fully implemented
- Dedup service is importable by analytics_tasks.py run_cheap_analytics
- All tests pass with no warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-batch-analytics/03-02-SUMMARY.md`
</output>
