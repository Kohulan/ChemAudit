---
phase: 01-deep-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/validation/checks/deep_composition.py
  - backend/app/services/validation/checks/__init__.py
  - backend/app/services/validation/engine.py
  - backend/tests/test_validation/test_deep_composition_checks.py
autonomous: true
requirements:
  - DVAL-06
  - DVAL-07
  - DVAL-08
  - DVAL-09
  - DVAL-10
  - DVAL-11

must_haves:
  truths:
    - "A mixture input (SMILES with dot separator like 'CCN.Cl') is flagged with each fragment classified as drug, salt, solvent, or unknown with SMILES, MW, and matched pattern name"
    - "A molecule containing a known solvent fragment (DMSO, DMF, water, etc.) returns a solvent contamination warning with the solvent name"
    - "An inorganic molecule (no carbon atoms) or organometallic (contains metals) is flagged with atom details"
    - "A molecule with radical electrons is flagged with affected atom indices"
    - "A molecule with isotope labels (e.g., deuterium, 13C) is flagged with isotope details per atom"
    - "A trivially small molecule (heavy atom count <= 3) is flagged as too small for meaningful validation"
  artifacts:
    - path: "backend/app/services/validation/checks/deep_composition.py"
      provides: "6 deep validation checks: mixture_detection, solvent_contamination, inorganic_filter, radical_detection, isotope_label_detection, trivial_molecule"
      contains: "@CheckRegistry.register"
    - path: "backend/tests/test_validation/test_deep_composition_checks.py"
      provides: "Tests for DVAL-06..11 checks"
      contains: "class TestMixtureDetection"
  key_links:
    - from: "backend/app/services/validation/checks/deep_composition.py"
      to: "backend/app/services/validation/registry.py"
      via: "@CheckRegistry.register() decorator"
      pattern: "@CheckRegistry\\.register"
    - from: "backend/app/services/validation/engine.py"
      to: "backend/app/services/validation/checks/deep_composition.py"
      via: "import to trigger registration"
      pattern: "import app\\.services\\.validation\\.checks\\.deep_composition"
---

<objective>
Implement the 6 Milestone 1.2 deep validation checks (DVAL-06 through DVAL-11) covering chemical composition guards: mixture detection with fragment classification, solvent contamination, inorganic/organometallic filtering, radical detection, isotope label detection, and trivial molecule flagging.

Purpose: These checks protect users from submitting mixtures, solvents, inorganic compounds, and other non-drug-like inputs that would produce misleading validation and scoring results.

Output: 6 new registered checks in `deep_composition.py` with comprehensive tests.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deep-validation/01-CONTEXT.md
@.planning/phases/01-deep-validation/01-RESEARCH.md
@backend/app/services/validation/checks/base.py
@backend/app/services/validation/checks/basic.py
@backend/app/services/validation/checks/__init__.py
@backend/app/services/validation/engine.py
@backend/app/services/validation/registry.py
@backend/app/schemas/common.py
@backend/tests/test_validation/test_stereo_checks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 6 chemical composition checks</name>
  <files>
    backend/app/services/validation/checks/deep_composition.py
    backend/app/services/validation/checks/__init__.py
    backend/app/services/validation/engine.py
  </files>
  <action>
Create `backend/app/services/validation/checks/deep_composition.py` with 6 check classes:

1. **MixtureDetectionCheck** (`mixture_detection`, category=`chemical_composition`):
   - Covers DVAL-06
   - Use `Chem.GetMolFrags(mol, asMols=True, sanitizeFrags=True)` to split into fragments
   - If only 1 fragment: passes (not a mixture)
   - For multi-fragment: classify each fragment using the helper function below
   - Fragment classification logic (private method `_classify_fragment`):
     a. Check against MolVS `REMOVE_FRAGMENTS` patterns: `from molvs.fragment import REMOVE_FRAGMENTS`. Each `FragmentPattern` has `.name` and `.smarts`. Use `frag_mol.HasSubstructMatch(Chem.MolFromSmarts(pattern.smarts))` if `.smarts` is a string, or `frag_mol.HasSubstructMatch(pattern.smarts)` if already a Mol.
     b. Classify by pattern name: names containing 'water', 'ammonia' → solvent; all others in REMOVE_FRAGMENTS → salt
     c. If no pattern match: use heuristic — has carbon AND MW > 100 → 'drug'; no carbon OR MW < 50 → 'salt'; else → 'unknown'
     d. Largest fragment by heavy atom count defaults to 'drug' if has carbon
   - Return `details`: `{num_fragments, fragments: [{smiles, molecular_weight, heavy_atom_count, classification, pattern_name}]}`
   - `affected_atoms`: empty (fragments are separate molecules)
   - Default severity: WARNING (mixtures may be intentional salt forms)
   - Human-readable message: "Input contains {n} fragments: {summary of classifications}."

2. **SolventContaminationCheck** (`solvent_contamination`, category=`chemical_composition`):
   - Covers DVAL-07
   - Define a curated SMARTS/SMILES dict of common lab solvents (supplement MolVS REMOVE_FRAGMENTS):
     ```python
     COMMON_SOLVENTS = {
         "water": "O",
         "DMSO": "CS(=O)C",
         "DMF": "CN(C)C=O",
         "acetonitrile": "CC#N",
         "methanol": "CO",
         "ethanol": "CCO",
         "acetone": "CC(=O)C",
         "THF": "C1CCCO1",
         "DCM": "ClCCl",
         "chloroform": "ClC(Cl)Cl",
         "toluene": "Cc1ccccc1",
         "hexane": "CCCCCC",
         "diethyl_ether": "CCOCC",
         "ethyl_acetate": "CCOC(=O)C",
         "isopropanol": "CC(O)C",
     }
     ```
   - Split mol into fragments, check each fragment against COMMON_SOLVENTS via canonical SMILES comparison and substructure match
   - Also check MolVS REMOVE_FRAGMENTS for water/ammonia patterns
   - If solvent found: fail with solvent name(s)
   - Return `details`: `{solvents_found: [{name, smiles, molecular_weight}], is_pure_solvent: bool}`
   - `is_pure_solvent`: true if the entire input IS the solvent (single fragment), false if solvent is part of a mixture
   - Default severity: WARNING
   - Human-readable message: "Detected solvent contaminant(s): {names}."

3. **InorganicFilterCheck** (`inorganic_filter`, category=`chemical_composition`):
   - Covers DVAL-08
   - Check if molecule contains any carbon atoms: `any(a.GetAtomicNum() == 6 for a in mol.GetAtoms())`
   - If no carbon: classify as inorganic
   - Also check for metals (organometallic): define METAL_ATOMIC_NUMS set (Li=3, Na=11, K=19, Mg=12, Ca=20, Fe=26, Cu=29, Zn=30, Co=27, Ni=28, Mn=25, Cr=24, V=23, Ti=22, Pd=46, Pt=78, Ru=44, Rh=45, Ir=77, Os=76, Au=79, Ag=47, plus lanthanides/actinides)
   - Return `details`: `{has_carbon, is_inorganic, is_organometallic, metal_atoms: [{atom_idx, symbol, atomic_num}], element_counts: {symbol: count}}`
   - `affected_atoms`: indices of metal atoms (if any)
   - Default severity: WARNING for organometallic, ERROR for purely inorganic
   - Human-readable message: "Molecule is {inorganic/organometallic}: contains {element summary}."

4. **RadicalDetectionCheck** (`radical_detection`, category=`chemical_composition`):
   - Covers DVAL-09
   - Iterate all atoms: `atom.GetNumRadicalElectrons()` — if > 0, flag
   - Return `details`: `{radical_atoms: [{atom_idx, symbol, num_radical_electrons}], total_radical_electrons}`
   - `affected_atoms`: indices of radical-bearing atoms
   - Default severity: WARNING
   - Human-readable message: "Detected {n} radical electron(s) on {atoms}."

5. **IsotopeLabelDetectionCheck** (`isotope_label_detection`, category=`chemical_composition`):
   - Covers DVAL-10
   - Iterate all atoms: `atom.GetIsotope()` — if > 0, it has a non-default isotope label
   - Common labels: 2H (deuterium), 3H (tritium), 13C, 14C, 15N, 18O, 18F, 32P, 35S
   - Return `details`: `{labeled_atoms: [{atom_idx, symbol, isotope_mass, common_name}], total_labeled}`
   - `common_name` maps: {(1,2): "deuterium", (1,3): "tritium", (6,13): "carbon-13", (6,14): "carbon-14", (7,15): "nitrogen-15", (8,18): "oxygen-18"} etc.
   - `affected_atoms`: indices of labeled atoms
   - Default severity: INFO (isotope labels are often intentional for pharmacokinetic studies)
   - Human-readable message: "Found {n} isotope-labeled atom(s): {summary}."

6. **TrivialMoleculeCheck** (`trivial_molecule`, category=`chemical_composition`):
   - Covers DVAL-11
   - Count heavy atoms: `sum(1 for a in mol.GetAtoms() if a.GetAtomicNum() != 1)` — but actually RDKit's `mol.GetNumHeavyAtoms()` is the cleaner API
   - Threshold: heavy_atom_count <= 3 (Claude's Discretion, aligns with ChEMBL fragment filter)
   - Also check: no bonds (`mol.GetNumBonds() == 0`) → single atom
   - Return `details`: `{heavy_atom_count, num_bonds, is_single_atom, threshold}`
   - Default severity: ERROR (trivially small molecules cannot be meaningfully validated)
   - Human-readable message: "Molecule has only {n} heavy atom(s) — too small for meaningful validation."

**Engine import:** Add `import app.services.validation.checks.deep_composition  # noqa: F401` in `engine.py` after the existing check imports (and after the deep_stereo_tautomer import if it exists from plan 01 — if plan 01 ran first; if not, just add after the stereo import).

**__init__.py update:** Add imports for the 6 new check classes and add them to `__all__`.

All checks must follow the same pattern as Plan 01 Task 1: inherit BaseCheck, register with decorator, include None guard, try/except, affected_atoms, details dict, human-readable message.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && python -c "
from app.services.validation.registry import CheckRegistry
import app.services.validation.checks.deep_composition
names = list(CheckRegistry.get_all().keys())
expected = {'mixture_detection', 'solvent_contamination', 'inorganic_filter', 'radical_detection', 'isotope_label_detection', 'trivial_molecule'}
missing = expected - set(names)
assert not missing, f'Missing checks: {missing}'
print(f'All 6 M1.2 checks registered: {expected}')
"</automated>
    <manual>Verify each check runs without error on a simple test molecule (aspirin SMILES: CC(=O)Oc1ccccc1C(=O)O)</manual>
  </verify>
  <done>6 check classes registered (mixture_detection, solvent_contamination, inorganic_filter, radical_detection, isotope_label_detection, trivial_molecule), engine imports them</done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive tests for M1.2 checks</name>
  <files>
    backend/tests/test_validation/test_deep_composition_checks.py
  </files>
  <action>
Create `backend/tests/test_validation/test_deep_composition_checks.py` following the pattern of `test_stereo_checks.py`.

**TestMixtureDetection class:**
- `test_single_molecule_passes`: `CCO` (ethanol) — passes, num_fragments=1
- `test_mixture_detected`: `CCN.Cl` (amine HCl salt) — fails, 2 fragments, one classified as drug, one as salt
- `test_three_component_mixture`: `CCN.[Na+].[Cl-]` — 3 fragments with correct classifications
- `test_fragment_classification_drug`: Largest carbon-containing fragment classified as 'drug'
- `test_fragment_classification_salt`: Small ions like `[Na+]`, `[Cl-]` classified as 'salt'
- `test_details_contain_required_fields`: Verify details.fragments has smiles, molecular_weight, classification, pattern_name
- `test_none_molecule_returns_error`

**TestSolventContamination class:**
- `test_no_solvent_passes`: `c1ccccc1` (benzene, but larger molecule like aspirin) — passes
- `test_water_detected`: `O` — solvent detected
- `test_dmso_detected`: `CS(=O)C` — solvent detected
- `test_methanol_detected`: `CO` — solvent detected
- `test_solvent_in_mixture`: `CCN.O` — solvent contamination in mixture context
- `test_pure_solvent_flag`: Single fragment that is a solvent → is_pure_solvent=true
- `test_none_molecule_returns_error`

**TestInorganicFilter class:**
- `test_organic_molecule_passes`: `CCO` — has carbon, passes
- `test_inorganic_detected`: `[Na+].[Cl-]` (NaCl) — no carbon, flagged as inorganic
- `test_organometallic_detected`: Molecule with a metal atom AND carbon — flagged as organometallic
- `test_metal_atoms_listed`: Verify affected_atoms contains metal atom indices
- `test_element_counts_in_details`: Verify details.element_counts is populated
- `test_none_molecule_returns_error`

**TestRadicalDetection class:**
- `test_no_radicals_passes`: `CCO` — no radicals
- `test_radical_detected`: Use `[CH2]` or `[O]` (oxygen radical) — radical flagged
- `test_affected_atoms_correct`: Verify affected_atoms matches radical atom indices
- `test_none_molecule_returns_error`

**TestIsotopeLabelDetection class:**
- `test_no_isotopes_passes`: `CCO` — no isotope labels
- `test_deuterium_detected`: `[2H]C([2H])([2H])O` (deuterated methanol) — isotope flagged
- `test_carbon13_detected`: `[13CH4]` — carbon-13 flagged
- `test_common_name_mapping`: Verify common_name field is correctly populated (e.g., "deuterium" for 2H)
- `test_none_molecule_returns_error`

**TestTrivialMolecule class:**
- `test_normal_molecule_passes`: `CCCCCCC` (heptane, 7 heavy atoms) — passes
- `test_single_atom_fails`: `[C]` or `[Na]` — fails, heavy_atom_count=1
- `test_water_fails`: `O` — fails, heavy_atom_count=1
- `test_threshold_boundary`: 3 heavy atoms (e.g., `C=O` formaldehyde-like, but need 3 heavy atoms exactly) — test boundary
- `test_four_heavy_atoms_passes`: 4 heavy atoms — passes
- `test_none_molecule_returns_error`

**TestRegistration class:**
- `test_all_m12_checks_registered`: Verify all 6 check names appear in `CheckRegistry.get_all()`

Use real RDKit molecules — do NOT mock RDKit.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && pytest tests/test_validation/test_deep_composition_checks.py -x -q</automated>
  </verify>
  <done>All tests pass for the 6 M1.2 checks covering mixture detection, solvent contamination, inorganic filter, radical detection, isotope labels, and trivial molecules</done>
</task>

</tasks>

<verification>
1. `cd backend && python -c "from app.services.validation.engine import validation_engine; checks = validation_engine.list_checks(); print(checks)"` shows `chemical_composition` category with 6 new check names
2. `cd backend && pytest tests/test_validation/test_deep_composition_checks.py -v` all tests pass
3. Smoke test: `cd backend && python -c "
from rdkit import Chem
from app.services.validation.engine import validation_engine
mol = Chem.MolFromSmiles('CCN.Cl')
results, score = validation_engine.validate(mol)
for r in results:
    if r.check_name in ('mixture_detection', 'solvent_contamination'):
        print(f'{r.check_name}: passed={r.passed}, details={r.details}')
"`
4. Existing tests still pass: `cd backend && pytest tests/test_validation/ -x -q`
</verification>

<success_criteria>
- 6 new check classes registered and discoverable by ValidationEngine
- Mixture detection returns fragment classification table with SMILES, MW, classification, pattern_name
- Solvent check detects common lab solvents (water, DMSO, DMF, methanol, etc.)
- Inorganic filter distinguishes inorganic from organometallic
- Radical and isotope checks return affected atom indices
- Trivial molecule threshold is heavy_atom_count <= 3
- All new tests pass; existing tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/01-deep-validation/01-02-SUMMARY.md`
</output>
