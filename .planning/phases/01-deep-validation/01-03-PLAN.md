---
phase: 01-deep-validation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/validation/checks/deep_complexity.py
  - backend/app/services/validation/checks/__init__.py
  - backend/app/services/validation/engine.py
  - backend/app/main.py
  - backend/tests/test_validation/test_deep_complexity_checks.py
autonomous: true
requirements:
  - DVAL-12
  - DVAL-13
  - DVAL-14
  - DVAL-15
  - DVAL-16
  - DVAL-17

must_haves:
  truths:
    - "A molecule with hypervalent atoms (exceeding normal valence) returns a warning with affected atom indices, actual vs allowed valences"
    - "A molecule with SGroup markers (polymer/repeating units in V3000 input) or MW > 1500 is flagged as a possible polymer"
    - "A molecule with 3 or 4-membered rings returns a ring strain warning with atom indices of each strained ring"
    - "A molecule with rings > 12 atoms returns a macrocycle warning with atom indices"
    - "A charged molecule returns charge details (net charge, positive/negative atom counts); zwitterions (net charge 0 with both + and - charges) are specifically flagged"
    - "A molecule with unusual explicit hydrogen patterns is flagged with affected atom indices"
    - "Startup assertion confirms all 17 deep validation check names are registered in CheckRegistry"
  artifacts:
    - path: "backend/app/services/validation/checks/deep_complexity.py"
      provides: "6 deep validation checks: hypervalent_atoms, polymer_detection, ring_strain, macrocycle_detection, charged_species, explicit_hydrogen_audit"
      contains: "@CheckRegistry.register"
    - path: "backend/tests/test_validation/test_deep_complexity_checks.py"
      provides: "Tests for DVAL-12..17 checks"
      contains: "class TestHypervalentAtoms"
    - path: "backend/app/main.py"
      provides: "Startup assertion for 16 deep validation check names"
      contains: "EXPECTED_DEEP_VALIDATION_CHECKS"
  key_links:
    - from: "backend/app/services/validation/checks/deep_complexity.py"
      to: "backend/app/services/validation/registry.py"
      via: "@CheckRegistry.register() decorator"
      pattern: "@CheckRegistry\\.register"
    - from: "backend/app/services/validation/engine.py"
      to: "backend/app/services/validation/checks/deep_complexity.py"
      via: "import to trigger registration"
      pattern: "import app\\.services\\.validation\\.checks\\.deep_complexity"
    - from: "backend/app/main.py"
      to: "backend/app/services/validation/registry.py"
      via: "startup assertion checking CheckRegistry"
      pattern: "EXPECTED_DEEP_VALIDATION_CHECKS"
---

<objective>
Implement the 6 Milestone 1.3 deep validation checks (DVAL-12 through DVAL-17) covering structural complexity flags: hypervalent atoms, polymer detection, ring strain, macrocycle detection, charged species/zwitterions, and explicit hydrogen audit. Also add a startup assertion that confirms all 16 deep validation checks (from all 3 milestones) are registered.

Purpose: These checks flag structural complexity patterns that affect compound processing, scoring, and ML model applicability — important context for chemists evaluating data quality.

Output: 6 new registered checks in `deep_complexity.py`, comprehensive tests, and a startup assertion in `main.py`.
</objective>

<execution_context>
@/Users/kohulanrajan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/kohulanrajan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-deep-validation/01-CONTEXT.md
@.planning/phases/01-deep-validation/01-RESEARCH.md
@backend/app/services/validation/checks/base.py
@backend/app/services/validation/checks/basic.py
@backend/app/services/validation/checks/__init__.py
@backend/app/services/validation/engine.py
@backend/app/services/validation/registry.py
@backend/app/schemas/common.py
@backend/app/main.py
@backend/tests/test_validation/test_stereo_checks.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 6 structural complexity checks + startup assertion</name>
  <files>
    backend/app/services/validation/checks/deep_complexity.py
    backend/app/services/validation/checks/__init__.py
    backend/app/services/validation/engine.py
    backend/app/main.py
  </files>
  <action>
Create `backend/app/services/validation/checks/deep_complexity.py` with 6 check classes:

1. **HypervalentAtomCheck** (`hypervalent_atoms`, category=`structural_complexity`):
   - Covers DVAL-12
   - Use `Chem.GetPeriodicTable()` to get `pt`, then `pt.GetValenceList(atom.GetSymbol())` for allowed valences
   - For each atom: compare `atom.GetTotalValence()` against allowed valences; if actual > max(allowed) and -1 not in allowed (unrestricted), flag as hypervalent
   - Skip dummy atoms (atomic_num == 0)
   - Return `details`: `{hypervalent_atoms: [{atom_idx, symbol, actual_valence, allowed_valences}]}`
   - `affected_atoms`: indices of hypervalent atoms
   - Default severity: WARNING
   - Wrapping in try/except per atom (some exotic atoms may fail GetValenceList)
   - Human-readable message: "Found {n} hypervalent atom(s): {summary}."

2. **PolymerDetectionCheck** (`polymer_detection`, category=`structural_complexity`):
   - Covers DVAL-13
   - Path 1 (SGroup markers): `Chem.GetMolSubstanceGroups(mol)` — if any SGroup with type containing 'SRU' (Structural Repeat Unit) or 'COP' (copolymer), flag as polymer
   - Path 2 (MW heuristic): Calculate `rdMolDescriptors.CalcExactMolWt(mol)` — if > 1500, flag as "possible polymer"
   - Path 3 (wildcard/dummy atoms): Check for atoms with atomic_num == 0 (dummy atoms like `[*]`) which indicate attachment points in polymer fragments
   - Return `details`: `{has_sgroup_markers, sgroup_types: [str], molecular_weight, exceeds_mw_threshold, has_dummy_atoms, dummy_atom_count}`
   - `affected_atoms`: indices of dummy atoms if present
   - Default severity: INFO (polymer detection is informational — high MW molecules may be natural products)
   - Human-readable message: "Possible polymer detected: {reason}."

3. **RingStrainCheck** (`ring_strain`, category=`structural_complexity`):
   - Covers DVAL-14
   - Use `mol.GetRingInfo().AtomRings()` to get all SSSR rings
   - Flag rings with `len(ring) in (3, 4)` — these are 3-membered (cyclopropane) and 4-membered (cyclobutane) rings
   - Per user decision: ring size heuristic ONLY, no force field calculation
   - Return `details`: `{strained_rings: [{ring_size, atom_indices}], total_strained_rings}`
   - `affected_atoms`: union of all atom indices in strained rings
   - Default severity: WARNING (ring strain affects stability)
   - Human-readable message: "Found {n} strained ring(s): {sizes}."

4. **MacrocycleDetectionCheck** (`macrocycle_detection`, category=`structural_complexity`):
   - Covers DVAL-15
   - Use `mol.GetRingInfo().AtomRings()` to get all SSSR rings
   - Flag rings with `len(ring) > 12` (per spec: >12 atoms)
   - Note SSSR limitation in output message (per Research pitfall #7): fused systems may not show all peripheral macrocyclic paths
   - Return `details`: `{macrocycles: [{ring_size, atom_indices}], total_macrocycles, sssr_note: "Uses SSSR; fused bicyclic peripheral paths may not be detected"}`
   - `affected_atoms`: union of all atom indices in macrocyclic rings
   - Default severity: INFO (macrocycles are valid drug candidates — cyclic peptides, macrolides)
   - Human-readable message: "Found {n} macrocyclic ring(s) with > 12 atoms."

5. **ChargedSpeciesCheck** (`charged_species`, category=`structural_complexity`):
   - Covers DVAL-16
   - Iterate atoms: `atom.GetFormalCharge()` — collect positively charged and negatively charged atoms
   - Net charge = sum of all formal charges
   - Zwitterion detection: net_charge == 0 AND has_positive AND has_negative
   - Return `details`: `{net_charge, positive_atoms: [{atom_idx, symbol, charge}], negative_atoms: [{atom_idx, symbol, charge}], is_zwitterion, total_charged_atoms}`
   - `affected_atoms`: indices of all charged atoms
   - Default severity: INFO (charged species are common and valid)
   - Human-readable message: "Net charge {n}. {Is/Is not} a zwitterion. {n} charged atom(s)."

6. **ExplicitHydrogenAuditCheck** (`explicit_hydrogen_audit`, category=`structural_complexity`):
   - Covers DVAL-17
   - Per Research pitfall #5: use `atom.GetNumExplicitHs()` (returns H count stored on heavy atom), NOT counting H atoms in mol.GetAtoms()
   - Flag atoms where `GetNumExplicitHs() > 0` AND explicit H count seems unusual:
     - Unusual = explicit H on atoms that RDKit would normally represent with implicit H (i.e., the explicit H count does not equal the default valence minus bonds)
     - Simpler approach: just report ALL atoms with `GetNumExplicitHs() > 0` along with the count, since users may want to know where explicit H is set
   - Also check if mol has separate H atom objects (atoms with atomic_num == 1 that are bonded to heavy atoms) which indicate the mol was processed with `AddHs()`
   - Return `details`: `{atoms_with_explicit_h: [{atom_idx, symbol, explicit_h_count}], total_explicit_h, has_h_atom_objects, h_atom_object_count}`
   - `affected_atoms`: indices of atoms with explicit H > 0
   - Default severity: INFO (explicit H is informational)
   - Human-readable message: "Found {n} atom(s) with explicit hydrogen specification."

**Engine import:** Add `import app.services.validation.checks.deep_complexity  # noqa: F401` in `engine.py` after the existing check imports.

**__init__.py update:** Add imports for the 6 new check classes and add them to `__all__`.

**Startup Assertion (STATE.md mandate + ROADMAP success criteria #5):**
In `backend/app/main.py`, inside the lifespan context manager (or wherever app startup logic lives), add an assertion after the validation engine import:

```python
# Deep validation check registration assertion
EXPECTED_DEEP_VALIDATION_CHECKS = {
    # M1.1: Stereo & Tautomer
    "stereoisomer_enumeration",      # DVAL-01+02
    "tautomer_detection",            # DVAL-03
    "aromatic_system_validation",    # DVAL-04
    "coordinate_dimension",          # DVAL-05
    # M1.2: Chemical Composition
    "mixture_detection",             # DVAL-06
    "solvent_contamination",         # DVAL-07
    "inorganic_filter",              # DVAL-08
    "radical_detection",             # DVAL-09
    "isotope_label_detection",       # DVAL-10
    "trivial_molecule",              # DVAL-11
    # M1.3: Structural Complexity
    "hypervalent_atoms",             # DVAL-12
    "polymer_detection",             # DVAL-13
    "ring_strain",                   # DVAL-14
    "macrocycle_detection",          # DVAL-15
    "charged_species",               # DVAL-16
    "explicit_hydrogen_audit",       # DVAL-17
}
from app.services.validation.registry import CheckRegistry
registered = set(CheckRegistry.get_all().keys())
missing = EXPECTED_DEEP_VALIDATION_CHECKS - registered
assert not missing, f"Startup assertion failed: missing deep validation checks: {missing}"
```

Place this assertion inside the app lifespan so it runs at startup. If there's an `@app.on_event("startup")` or `lifespan` async context manager, add it there. If not, add it at module level after the engine is imported (it will execute when the module loads).

Note: This assertion covers ALL 16 deep validation checks (from all 3 plans). If plans 01 and 02 haven't run yet, the assertion will fail. The executor should be aware that this assertion is additive — it validates the complete set. If needed, wrap in a try/except with a warning log instead of hard assert during development, then switch to hard assert once all 3 plans are complete. OR: use `logger.warning` instead of `assert` to allow partial deployments, with a CI test that does the hard assert.

RECOMMENDED APPROACH: Use `logger.warning` for the startup check (allows partial deploys), and add a separate CI test in the test file that does the hard assert.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && python -c "
from app.services.validation.registry import CheckRegistry
import app.services.validation.checks.deep_complexity
names = list(CheckRegistry.get_all().keys())
expected = {'hypervalent_atoms', 'polymer_detection', 'ring_strain', 'macrocycle_detection', 'charged_species', 'explicit_hydrogen_audit'}
missing = expected - set(names)
assert not missing, f'Missing checks: {missing}'
print(f'All 6 M1.3 checks registered: {expected}')
"</automated>
    <manual>Verify the startup assertion runs without error when all 16 checks are present</manual>
  </verify>
  <done>6 check classes registered (hypervalent_atoms, polymer_detection, ring_strain, macrocycle_detection, charged_species, explicit_hydrogen_audit), engine imports them, startup assertion checks all 16 deep validation checks</done>
</task>

<task type="auto">
  <name>Task 2: Write comprehensive tests for M1.3 checks + CI registration test</name>
  <files>
    backend/tests/test_validation/test_deep_complexity_checks.py
  </files>
  <action>
Create `backend/tests/test_validation/test_deep_complexity_checks.py` following the test_stereo_checks.py pattern.

**TestHypervalentAtoms class:**
- `test_normal_molecule_passes`: `CCO` (ethanol) — all normal valences, passes
- `test_hypervalent_sulfur_detected`: Use pentavalent phosphorus or hypervalent sulfur if parseable — test with `S(=O)(=O)(O)(O)(O)O` (sulfuric acid derivative) or similar. Note: RDKit may sanitize some hypervalent patterns to valid valence. Use a molecule that RDKit accepts but has atoms exceeding the standard valence list.
- `test_affected_atoms_populated`: Verify affected_atoms contains correct indices
- `test_details_structure`: Verify details has hypervalent_atoms list with atom_idx, symbol, actual_valence, allowed_valences
- `test_none_molecule_returns_error`

**TestPolymerDetection class:**
- `test_normal_molecule_passes`: `CCO` (ethanol) — MW << 1500, no SGroups, passes
- `test_high_mw_flagged`: Create a large molecule (long alkane chain) with MW > 1500 → flagged as possible polymer
- `test_dummy_atoms_flagged`: Use `[*]CC[*]` — has dummy atoms, flagged
- `test_details_structure`: Verify details has has_sgroup_markers, molecular_weight, has_dummy_atoms
- `test_none_molecule_returns_error`

**TestRingStrain class:**
- `test_no_small_rings_passes`: `c1ccccc1` (benzene, 6-membered ring) — passes
- `test_cyclopropane_flagged`: `C1CC1` (3-membered ring) — ring strain warning
- `test_cyclobutane_flagged`: `C1CCC1` (4-membered ring) — ring strain warning
- `test_cyclopentane_passes`: `C1CCCC1` (5-membered ring) — passes
- `test_multiple_strained_rings`: Molecule with both 3- and 4-membered rings
- `test_affected_atoms_correct`: Verify affected_atoms contains ring atom indices
- `test_none_molecule_returns_error`

**TestMacrocycleDetection class:**
- `test_small_ring_passes`: `c1ccccc1` — 6-membered, not macrocyclic
- `test_macrocycle_detected`: Use a 14-membered ring or larger (e.g., cyclotetradecane: `C1CCCCCCCCCCCCC1` — 14 atoms in ring) → macrocycle flagged
- `test_12_atom_ring_passes`: Exactly 12-atom ring — should NOT be flagged (>12, not >=12)
- `test_13_atom_ring_flagged`: 13-atom ring — should be flagged
- `test_affected_atoms_correct`: Ring atom indices in affected_atoms
- `test_none_molecule_returns_error`

**TestChargedSpecies class:**
- `test_neutral_molecule_passes`: `CCO` — no charge
- `test_positive_charge_detected`: `[NH3+]CC` — positive charge
- `test_negative_charge_detected`: `CC([O-])=O` — negative charge (carboxylate)
- `test_zwitterion_detected`: `[NH3+]CCC([O-])=O` (amino acid form) — net charge 0, is_zwitterion=true
- `test_net_charge_calculated`: Verify net_charge in details is correct sum
- `test_affected_atoms_correct`: Charged atom indices in affected_atoms
- `test_none_molecule_returns_error`

**TestExplicitHydrogenAudit class:**
- `test_normal_smiles_passes`: `CCO` (parsed from SMILES, implicit H) — may pass or report minimal explicit H
- `test_explicit_h_detected`: Create mol from SMILES and call `Chem.AddHs(mol)` → atoms_with_explicit_h should be populated; OR use bracket notation like `[CH4]` that forces explicit H count
- `test_h_atom_objects_detected`: After `Chem.AddHs(mol)`, verify has_h_atom_objects=true
- `test_none_molecule_returns_error`

**TestRegistration class:**
- `test_all_m13_checks_registered`: Verify all 6 check names in `CheckRegistry.get_all()`

**TestAllDeepValidationChecks class (CI cross-check per ROADMAP success criteria #5):**
- `test_all_16_deep_validation_checks_registered`: Import all three deep check modules, then verify ALL 16 expected check names are registered. This is the CI-level hard assertion:
```python
EXPECTED_DEEP_VALIDATION_CHECKS = {
    "stereoisomer_enumeration", "tautomer_detection", "aromatic_system_validation", "coordinate_dimension",
    "mixture_detection", "solvent_contamination", "inorganic_filter", "radical_detection", "isotope_label_detection", "trivial_molecule",
    "hypervalent_atoms", "polymer_detection", "ring_strain", "macrocycle_detection", "charged_species", "explicit_hydrogen_audit",
}
registered = set(CheckRegistry.get_all().keys())
missing = EXPECTED_DEEP_VALIDATION_CHECKS - registered
assert not missing, f"CI check: missing deep validation checks: {missing}"
```
- `test_check_file_count_matches_registry`: Count the number of `.py` files in `checks/` directory (excluding `__init__.py`, `base.py`, `__pycache__`) and verify it matches the expected count. This cross-checks that no check file was added without registration.

Use real RDKit molecules — do NOT mock RDKit.
  </action>
  <verify>
    <automated>cd /Volumes/Data_Drive/Project/2026/chemstructval/backend && pytest tests/test_validation/test_deep_complexity_checks.py -x -q</automated>
  </verify>
  <done>All tests pass for the 6 M1.3 checks and the CI cross-check confirms all 16 deep validation checks are registered</done>
</task>

</tasks>

<verification>
1. `cd backend && python -c "from app.services.validation.engine import validation_engine; checks = validation_engine.list_checks(); print(checks)"` shows `structural_complexity` category with 6 new check names
2. `cd backend && pytest tests/test_validation/test_deep_complexity_checks.py -v` all tests pass
3. `cd backend && pytest tests/test_validation/test_deep_complexity_checks.py::TestAllDeepValidationChecks -v` CI cross-check passes (all 16 checks registered)
4. Existing tests still pass: `cd backend && pytest tests/test_validation/ -x -q`
5. Startup assertion: `cd backend && python -c "from app.main import app; print('Startup assertion passed')"` runs without assertion error
</verification>

<success_criteria>
- 6 new check classes registered and discoverable by ValidationEngine
- Ring strain detects 3/4-membered rings (heuristic only, no force field)
- Macrocycle threshold is >12 atoms (not >=12)
- Zwitterion detection correctly identifies net-zero charge with both + and - charges
- Startup assertion or warning covers all 16 deep validation checks
- CI test hard-asserts all 16 checks are registered
- All new tests pass; existing tests unbroken
</success_criteria>

<output>
After completion, create `.planning/phases/01-deep-validation/01-03-SUMMARY.md`
</output>
